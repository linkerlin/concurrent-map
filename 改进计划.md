# concurrent-map 改进计划 ✅ 已完成

> 基于 Go Expert 视角的全面代码审查与改进建议
> 
> **状态**: 所有改进已完成，测试覆盖率 99.5%

## 项目概述

`concurrent-map` 是一个高性能的 Go 并发安全 Map 实现，采用分片(sharding)策略减少锁竞争。项目使用 Go 1.18+ 泛型特性，支持任意 comparable 类型的键。

---

## 一、代码质量改进

### 1.1 文档与注释规范

**现状问题：**
- 部分函数注释存在拼写错误（如 `IterCb` 的注释 "callbacalled"）
- 注释格式不统一，有的以 `//` 开头，有的没有空格
- 缺少关键设计决策的文档说明

**改进建议：**
```go
// 改进前
// Iterator callbacalled for every key,value found in
// maps. RLock is held for all calls for a given shard
// therefore callback sess consistent view of a shard,
// but not across the shards

// 改进后
// IterCb executes the callback function for every key-value pair in the map.
// The RLock is held for all calls within a given shard, ensuring a consistent
// view of that shard. However, consistency is not guaranteed across different shards.
// This is the most efficient way to iterate over all elements.
```

### 1.2 错误处理与边界情况

**现状问题：**
- `Clear()` 方法存在性能问题和潜在竞态条件
- `UnmarshalJSON` 在 nil map 上调用会导致 panic

**改进建议：**
```go
// 当前 Clear 实现的问题：逐个删除，性能差，且迭代过程中其他 goroutine 可能修改 map
func (m ConcurrentMap[K, V]) Clear() {
    for item := range m.IterBuffered() {
        m.Remove(item.Key)
    }
}

// 建议改进：直接重建 shards，O(1) 操作，原子性更好
func (m ConcurrentMap[K, V]) Clear() {
    for i := 0; i < SHARD_COUNT; i++ {
        shard := m.shards[i]
        shard.Lock()
        shard.items = make(map[K]V)  // 直接替换，让 GC 处理旧 map
        shard.Unlock()
    }
}
```

### 1.3 代码风格一致性

**问题清单：**
1. `SHARD_COUNT` 使用全局变量，存在并发修改风险
2. 部分函数返回值命名不一致（如 `Upsert` 有命名返回值 `res`，其他函数没有）
3. 空行使用不一致

**改进建议：**
```go
// 将 SHARD_COUNT 改为常量，或封装为配置选项
const DefaultShardCount = 32

type ConcurrentMap[K comparable, V any] struct {
    shards   []*ConcurrentMapShared[K, V]
    sharding func(key K) uint32
    shardCount int  // 实例级别配置，避免全局变量问题
}
```

---

## 二、性能优化

### 2.1 内存分配优化

**现状分析：**
- `Items()` 和 `Keys()` 方法预先分配容量，但 `Count()` 需要遍历所有 shard
- `IterBuffered()` 需要两次遍历（一次计算容量，一次发送数据）

**优化方案：**
```go
// 添加预估容量方法，避免精确的 Count() 调用
func (m ConcurrentMap[K, V]) Items() map[K]V {
    // 预估容量：每个 shard 平均大小 * shard 数量
    tmp := make(map[K]V, SHARD_COUNT*16)  // 预分配合理初始容量
    
    for item := range m.IterBuffered() {
        tmp[item.Key] = item.Val
    }
    return tmp
}
```

### 2.2 锁粒度优化

**现状问题：**
- `MSet` 逐个获取锁，没有利用批量操作优势
- `Count()` 需要获取所有 shard 的读锁

**优化建议：**
```go
// 批量设置优化：按 shard 分组后批量写入
func (m ConcurrentMap[K, V]) MSet(data map[K]V) {
    // 按 shard 分组
    grouped := make([][]Tuple[K, V], SHARD_COUNT)
    for k, v := range data {
        shardIdx := uint(m.sharding(k)) % uint(SHARD_COUNT)
        grouped[shardIdx] = append(grouped[shardIdx], Tuple[K, V]{k, v})
    }
    
    // 逐个 shard 批量写入
    for i, items := range grouped {
        if len(items) == 0 {
            continue
        }
        shard := m.shards[i]
        shard.Lock()
        for _, item := range items {
            shard.items[item.Key] = item.Val
        }
        shard.Unlock()
    }
}
```

### 2.3 迭代器性能

**现状问题：**
- `Iter()` 已标记为 Deprecated，但仍需维护
- `snapshot()` 函数在空 map 时 panic

**改进建议：**
```go
// 添加更高效的遍历方式：无回调、无 channel
func (m ConcurrentMap[K, V]) Range(f func(key K, value V) bool) {
    for _, shard := range m.shards {
        shard.RLock()
        for k, v := range shard.items {
            if !f(k, v) {
                shard.RUnlock()
                return
            }
        }
        shard.RUnlock()
    }
}
```

---

## 三、API 设计改进

### 3.1 缺失的核心功能

| 功能 | 重要性 | 建议实现 |
|------|--------|----------|
| `GetOrSet` | 高 | 原子性获取或设置，避免重复计算 |
| `GetAndSet` | 中 | 返回旧值并设置新值 |
| `Size()` 别名 | 低 | 与 `Count()` 保持一致 |
| `Clone()` | 中 | 深拷贝整个 map |
| `Merge()` | 低 | 合并另一个 concurrent-map |

**GetOrSet 实现示例：**
```go
// GetOrSet returns the existing value for the key if present.
// Otherwise, it sets and returns the given value.
// The loaded result is true if the value was loaded, false if set.
func (m ConcurrentMap[K, V]) GetOrSet(key K, value V) (actual V, loaded bool) {
    shard := m.GetShard(key)
    shard.Lock()
    if v, ok := shard.items[key]; ok {
        shard.Unlock()
        return v, true
    }
    shard.items[key] = value
    shard.Unlock()
    return value, false
}
```

### 3.2 泛型约束优化

**现状问题：**
- `Stringer` 接口定义混合了 `fmt.Stringer` 和 `comparable`
- 自定义分片函数签名限制为 `uint32`

**改进建议：**
```go
// 支持更多哈希返回类型
type Hasher[K comparable] interface {
    Hash(key K) uint32
}

// 或支持 64 位哈希，减少冲突
type ShardingFunction[K comparable] func(key K) uint64
```

### 3.3 上下文支持

**建议添加：**
```go
// SetWithContext sets a value with context cancellation support
func (m ConcurrentMap[K, V]) SetWithContext(ctx context.Context, key K, value V) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        m.Set(key, value)
        return nil
    }
}
```

---

## 四、测试改进

### 4.1 测试覆盖率

**现状分析：**
- 基础功能测试较完善
- 缺少边界条件测试（nil 值、空字符串键等）
- 缺少压力测试和长时间运行测试

**建议添加的测试：**
```go
// 测试 nil 值处理
func TestNilValues(t *testing.T) {
    m := New[*Animal]()
    m.Set("nil", nil)
    val, ok := m.Get("nil")
    if !ok || val != nil {
        t.Error("nil value handling failed")
    }
}

// 测试并发删除和迭代
func TestConcurrentRemoveDuringIteration(t *testing.T) {
    m := New[int]()
    for i := 0; i < 1000; i++ {
        m.Set(strconv.Itoa(i), i)
    }
    
    var wg sync.WaitGroup
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        for item := range m.IterBuffered() {
            _ = item.Val
        }
    }()
    
    go func() {
        defer wg.Done()
        for i := 0; i < 1000; i++ {
            m.Remove(strconv.Itoa(i))
        }
    }()
    
    wg.Wait()
}
```

### 4.2 Benchmark 改进

**建议添加：**
```go
// 测试不同分片数量的性能
func BenchmarkShardCountComparison(b *testing.B) {
    for _, shards := range []int{1, 16, 32, 64, 128, 256} {
        b.Run(fmt.Sprintf("shards-%d", shards), func(b *testing.B) {
            old := SHARD_COUNT
            SHARD_COUNT = shards
            defer func() { SHARD_COUNT = old }()
            
            m := New[int]()
            b.ResetTimer()
            b.RunParallel(func(pb *testing.PB) {
                i := 0
                for pb.Next() {
                    m.Set(strconv.Itoa(i), i)
                    i++
                }
            })
        })
    }
}
```

---

## 五、工程化改进

### 5.1 CI/CD 配置

**`.travis.yml` 已过时，建议迁移到 GitHub Actions：**

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.18', '1.19', '1.20', '1.21', '1.22', '1.23']
    
    steps:
    - uses: actions/checkout@v4
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ matrix.go-version }}
    
    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out ./...
    
    - name: Run benchmarks
      run: go test -bench=. -benchmem ./...
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
```

### 5.2 代码质量工具

**建议添加：**
- `golangci-lint` 配置
- `go fmt` / `gofumpt` 格式化
- `go vet` 静态分析
- `staticcheck` 深度检查

```yaml
# .golangci.yml
linters:
  enable:
    - gofmt
    - govet
    - staticcheck
    - errcheck
    - ineffassign
    - gosimple
    - typecheck
    - unused
    - misspell
```

### 5.3 版本管理

**建议：**
- 使用语义化版本（Semantic Versioning）
- 添加 `CHANGELOG.md`
- 打 tag 时发布 release notes

---

## 六、优先级与实施计划

### Phase 1: 关键修复（立即执行）

1. **修复 `Clear()` 方法** - 性能问题和竞态条件
2. **修复注释拼写错误** - 提升代码可读性
3. **添加 `GetOrSet` 方法** - 高频使用场景
4. **更新 CI 配置** - 从 Travis 迁移到 GitHub Actions

### Phase 2: 性能优化（1-2 周）

1. 优化 `MSet` 批量写入
2. 添加 `Range` 遍历方法
3. 优化内存预分配策略
4. 添加更多 benchmark 对比

### Phase 3: API 扩展（2-4 周）

1. 添加 `GetAndSet`、`Clone`、`Merge` 等方法
2. 支持 64 位哈希函数
3. 添加上下文支持的方法变体
4. 完善测试覆盖率（目标 >90%）

### Phase 4: 工程化完善（持续）

1. 添加代码质量工具链
2. 完善文档和示例
3. 性能调优指南
4. 贡献者指南更新

---

## 七、参考资源

- [Go 官方 Map 使用指南](https://go.dev/blog/maps)
- [sync.Map 设计文档](https://github.com/golang/go/issues/21035)
- [Go 泛型最佳实践](https://go.dev/doc/tutorial/generics)
- [高性能 Go 代码编写](https://github.com/dgryski/go-perfbook)

---

*本改进计划由 Go Expert 锦囊生成，建议根据实际业务需求调整优先级。*
